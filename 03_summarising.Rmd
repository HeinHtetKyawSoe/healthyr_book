---
output:
  pdf_document: default
  html_document: default
---
# Summarising data

In this session we will get to know our three best friends for summarising data: `group_by()`, `summarise()`, and `mutate()`.

## Data: Global Burden of Disease (year, cause, sex, income, deaths)

```{r, include = FALSE}
source("healthyr_theme.R")
gbd_short = read_csv("data/global_burden_disease_SHORT.csv")
```


The Global Burden of Disease dataset used in this chapter is more detailed than the one we used previously. For each year, the total number of deaths from the three broad disease categories are also separated into sex and World Bank income categories. This means that we have 24 rows for each year, and that the total number of deaths per year is the sum of these 24 rows:


```{r, message=F}
library(tidyverse)
gbd_long  = read_csv("data/global_burden_disease_LONG.csv")

# Creating a single-year tibble for printing and simple examples:
gbd2017 = gbd_long %>% 
  filter(year == 2017)
```

```{r chap3-tab-gbd2017, echo = FALSE}
gbd2017 %>% 
  knitr::kable(booktabs = TRUE,
               linesep = c(rep("", 3), "\\addlinespace"),
               align = c("l", "c", "r", "l", "c", "r"),
               caption = "Deaths per year from three broad disease categories, sex, and World Bank county-level income groups.") %>% 
  kableExtra::kable_styling(latex_options = c("hold_position"),
                            font_size = 10)

```

\clearpage

The best way to investigate a dataset is of course to plot it. We have added a couple of notes as comments (the lines starting with a `#`) for those who can't wait to get to the next chapter where the code for plotting will be introduced and explained in detail. Overall, you shouldn't waste time trying to understand this code here but to look at the different groups within this new dataset.

```{r fig.height=3, fig.width=6}
gbd2017 %>% 
  # without the mutate(... = fct_relevel()) 
  # the panels get ordered alphabetically
  mutate(income = fct_relevel(income,
                              "Low",
                              "Lower-Middle",
                              "Upper-Middle",
                              "High")) %>% 
  # defining the variables using ggplot(aes(...)):
  ggplot(aes(x = sex, y = deaths_millions, fill = cause)) +
  # type of geom to be used: column (that's a type of barplot):
  geom_col(position = "dodge") +
  # facets for the income groups:
  facet_wrap(~income, ncol = 4) +
  # move the legend to the top of the plot (default is "right"):
  theme(legend.position = "top")
```

To quickly calculate the total number of deaths in 2017, we can select the column and send it into the `sum()` function:

```{r}
gbd2017$deaths_millions %>% sum()
```

But a mich cleverer way of summarising data is using the `summarise()` function:

```{r}
gbd2017 %>% 
  summarise(sum(deaths_millions))
```

And this is indeed equal to the number of deaths per year we were looking at in the shorter version of this data (Deaths from the three causes were `r gbd_short %>%filter(year == 2017) %>% pull(deaths_millions)` which adds to `r gbd_short %>%filter(year == 2017) %>% pull(deaths_millions) %>% sum()`).




```{r, fig.width=6, fig.height=4}

# mydata %>% 
# 	ggplot(aes(x = year, y = deaths_millions, fill = cause))+ 
# 	geom_col(colour = "black")
# 
# 
# mydata %>% 
# 	filter(year == 1990)
```



## Basic functions for summarising data

You can always pick a column and ask R to give you the `sum()`, `mean()`, `min()`, `max()`, etc. for it:

```{r}
# mydata$deaths_millions %>% sum()
# mydata$deaths_millions %>% mean()

```

But if you want to get the total number of deaths for each `year` (or `cause`, or `sex`, whichever grouping variables you have in your dataset) you can use `group_by()` and `summarise()` that make subgroup analysis very convenient and efficient.


## Subgroup analysis: `group_by()` and `summarise()`

The `group_by()` function tells R that you are about to perform subgroup analysis on your data. 
It retains information about your groupings and calculations are applied on each group separately. 
To go back to summarising the whole dataset again use `ungroup()`. Note that `summarise()` is different to the `summary()` function we used in Session 2.

With `summarise()`, we can calculate the total number of deaths per year:
