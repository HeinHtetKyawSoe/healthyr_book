---
output:
  pdf_document: default
  html_document: default
---

```{r, include = FALSE}
options(pillar.sigfig = 4)
```

# Summarising data

>â€œThe Answer to the Great Question... Of Life, the Universe and Everything... Is... Forty-two," said Deep Thought, with infinite majesty and calm. 
>Douglas Adams, The Hitchhiker's Guide to the Galaxy

In this chapter we will get to know our three best friends for summarising data: `group_by()`, `summarise()`, and `mutate()`.

## Dataset: Global Burden of Disease (year, cause, sex, income, deaths)

```{r, include = FALSE}
source("healthyr_theme.R")
gbd_short = read_csv("data/global_burden_disease_cause-year.csv")
```


The Global Burden of Disease dataset used in this chapter is more detailed than the one we used previously. For each year, the total number of deaths from the three broad disease categories are also separated into sex and World Bank income categories. This means that we have 24 rows for each year, and that the total number of deaths per year is the sum of these 24 rows:


```{r, message=F}
library(tidyverse)
gbd_long  = read_csv("data/global_burden_disease_cause-year-sex-income.csv")

# Creating a single-year tibble for printing and simple examples:
gbd2017 = gbd_long %>% 
  filter(year == 2017)

```

```{r chap3-tab-gbd2017, echo = FALSE}
gbd2017 %>% 
  knitr::kable(booktabs = TRUE,
               linesep = c(rep("", 3), "\\addlinespace"),
               align = c("l", "c", "r", "l", "c", "r"),
               caption = "Deaths per year from three broad disease categories, sex, and World Bank county-level income groups.") %>% 
  kableExtra::kable_styling(latex_options = c("hold_position"),
                            font_size = 10)

```

\clearpage

The best way to investigate a dataset is of course to plot it. We have added a couple of notes as comments (the lines starting with a `#`) for those who can't wait to get to the next chapter where the code for plotting will be introduced and explained in detail. Overall, you shouldn't waste time trying to understand this code here but to look at the different groups within this new dataset.

```{r  chap03-fig-gbd, fig.height=3, fig.width=6, fig.cap="Global Burden of Disease data with subgroups: cause, sex, World Bank income group."}
gbd2017 %>% 
  # without the mutate(... = fct_relevel()) 
  # the panels get ordered alphabetically
  mutate(income = fct_relevel(income,
                              "Low",
                              "Lower-Middle",
                              "Upper-Middle",
                              "High")) %>% 
  # defining the variables using ggplot(aes(...)):
  ggplot(aes(x = sex, y = deaths_millions, fill = cause)) +
  # type of geom to be used: column (that's a type of barplot):
  geom_col(position = "dodge") +
  # facets for the income groups:
  facet_wrap(~income, ncol = 4) +
  # move the legend to the top of the plot (default is "right"):
  theme(legend.position = "top")
```

## Aggregating: `group_by()`, `summarise()`

To quickly calculate the total number of deaths in 2017, we can select the column and send it into the `sum()` function:

```{r}
gbd2017$deaths_millions %>% sum()
```

But a much cleverer way of summarising data is using the `summarise()` function:

```{r}
gbd2017 %>% 
  summarise(sum(deaths_millions))
```

And this is indeed equal to the number of deaths per year we were looking at in the shorter version of this data (Deaths from the three causes were `r gbd_short %>%filter(year == 2017) %>% pull(deaths_millions)` which adds to `r gbd_short %>%filter(year == 2017) %>% pull(deaths_millions) %>% sum()`).

`sum()` is a function that adds numbers together, whereas `summarise()` is a clever and efficient way of creating summarised tibbles. The main strength of `sumarise()` is how it works together with the `group_by()` function. We use `group_by()` to tell `summarise()` which subgroups to apply the calculations on. In the above example, without `group_by()`, summarise just works on the whole dataset, yielding the same result as just sending a single column into the `sum()` function. But if we add `group_by()` like this, e.g., for the `cause` variable:

```{r}
gbd2017 %>% 
  group_by(cause) %>% 
  summarise(sum(deaths_millions))
```

Furthermore, `group_by()` is happy accept multiple grouping variables. So by just copying and editing the above code, we can quickly get summarised totals across multiple grouping variables (by just adding `sex` inside the `group_by()` after `cause`):

```{r}
gbd2017 %>% 
  group_by(cause, sex) %>% 
  summarise(sum(deaths_millions))
```

## Add new columns: `mutate()`

Let's give the summarised column a better name, e.g. `deaths_pergroup`. And, if we use `ungroup()` we can use `mutate()` to add a total deaths column, and we can then use it to calculate a percentage:

```{r}
gbd2017 %>% 
  group_by(cause, sex) %>% 
  summarise(deaths_pergroups = sum(deaths_millions)) %>% 
  ungroup() %>% 
  mutate(deaths_total = sum(deaths_pergroups))
```


### percentages formatting: `percent()`

So `summarise()` condenses a tibble, whereas `mutate()` retains it's current size and adds columns. We can also further lines to `mutate()` to calculate the percentage of each group:

```{r, message = FALSE}
# percent() function for formatting percentages come from library(scales)
library(scales)
gbd2017 %>% 
  group_by(cause, sex) %>% 
  summarise(deaths_pergroups = sum(deaths_millions)) %>% 
  ungroup() %>% 
  mutate(deaths_total    = sum(deaths_pergroups),
         deaths_relative = percent(deaths_pergroups/deaths_total))
```


The `percent()` function that comes from `library(scales)` is a very handy way of formatting percentages, but you have to keep in mind that it changes the column from a number (denoted `<dbl>`) to a character (`<chr>`). The `percent()` function is basically equivalent to:

```{r}
# using values from the first row as an example:
round(100*4.91/55.74, 1) %>% paste0("%")
```

This is very convenient for final presentation of number, but if you intend to do further calculations/plot/sort the percentages just calculate them as fractions with:

```{r, eval = FALSE}
mydata %>% 
  mutate(deaths_relative = deaths_pergroups/deaths_total)
```

and convert to nicely formatted percentages later:

```{r, eval = FALSE}
mydata %>% 
  mutate(deaths_percentage = percent(deaths_relative))
```


## `summarise()` vs `mutate()`

So far we've shown you examples of using `summarise()` on grouped data (so following `group_by()`) and `mutate()` on the whole dataset (either without using `group_by()` at all, or resetting the grouping information with `ungroup()`).

But here's the thing: `mutate()` is also happy to work on grouped data!

Let's save the aggregated (one of the `summarise()` examples from above) in a new tibble, and let's `arrange()` the rows based on `sex`, just for easier viewing (it was previously sorted/arranged by `cause`).

The `arrange()` function sorts the rows within a tibble:


```{r}
gbd_summarised = 
  gbd2017 %>% 
  group_by(cause, sex) %>% 
  summarise(deaths_pergroups = sum(deaths_millions)) %>% 
  arrange(sex)

gbd_summarised
```

You should also notice that `summarise()` drops all variables that are not listed in `group_by()` or created inside it. So `year`, `income`, and `deaths_millions` exist in `gbd2017`, but they do not exist in `gbd_summarised`.


We now want to calculate the percentage of deaths from each cause for each gender. We could use `summarise()` to calculate the totals:

```{r}
gbd_summarised_sex =
  gbd_summarised %>% 
  group_by(sex) %>% 
  summarise(deaths_persex = sum(deaths_pergroups))

gbd_summarised_sex
```

But that drops the `cause` and `deaths_pergroups` columns. One way would be to now use a join on `gbd_summarised` and `gbd_summarised_sex`:

```{r}
full_join(gbd_summarised, gbd_summarised_sex)
```

And joining different summaries together is a good idea, especially if the individual pipelines are quite long (e.g., over 5 lines of `%>%`) - as it is reasonable to save the interim results in separate tibbles (like we've saved `gbd_summarised` and `gbd_summarised_sex`), check that they have worked as expected, and then join together.



But in simpler examples, we can use `mutate()` with `group_by()` to achieve the same result as the `full_join()` above:

```{r}
gbd_summarised %>% 
  group_by(sex) %>% 
  mutate(deaths_persex = sum(deaths_pergroups))
```


So `mutate()` calculates the sums within each grouping variable (in this example just `group_by(sex)`) and puts the results in a new column without condensing the tibble down or removing any of the existing columns.

Let's combine all of this together into a single pipeline and calculate the percentages per cause for each gender:


```{r}
gbd2017 %>% 
  group_by(cause, sex) %>% 
  summarise(deaths_pergroups = sum(deaths_millions)) %>% 
  group_by(sex) %>% 
  mutate(deaths_persex  = sum(deaths_pergroups),
         sex_cause_perc = percent(deaths_pergroups/deaths_persex)) %>% 
  arrange(sex, deaths_pergroups)
```

## Common arithmetic functions - `sum()`, `mean()`, `median()`, etc.

Statistics is what R does, so if there is an arthemtic function you can think of it will already exist in R.

The most common ones are:

* `sum()`
* `mean()`
* `median()`
* `min()`, `max()`
* `sd()` - standard deviation
* `IQR()` - inter-quartile range


The import thing to remember about all of these is that if any of the values is NA (not applicable/not available), these functions will return an NA. 
Either deal with your missing values beforehand (recommended) or add the `na.rm = TRUE` argument into any of the above functions to ask R to ignore missing values. 
More discussion and examples around missing data can be found in Chapters \@ref(r-basics) and \@ref(missing-data).

```{r}
mynumbers = c(1, 2, NA)
sum(mynumbers)
sum(mynumbers, na.rm = TRUE)
```


## `select()` columns


## Reshaping data - long vs wide format

So far, all of the example we've shown you have been using 'tidy' data. Data is 'tidy' where each variable is in its own column, and each observation is in its own row. 
This long looking format is efficient to use in data analysis and visualisation, it can also be refered to as "computer readable". 
But sometimes when presenting data in tables for humans to have a look, or when collecting data directly into a Spreadsheet, it is convenient for us, humans, to have data in a "wide" format. 

```{r, message = FALSE}
gbd_wide = read_csv("data/global_burden_disease_wide-format.csv")
gbd_long = read_csv("data/global_burden_disease_cause-sex-year.csv")
```


```{r chap3-tab-gbd-wide, echo = FALSE}
gbd_wide %>% 
  knitr::kable(booktabs = TRUE,
               linesep = c(rep("", 3), "\\addlinespace"),
               align = c("l", "c", "c", "c", "c"),
               caption = "Global Burden of Disease data in human-readable wide format. This is not tidy data.") %>% 
  kableExtra::kable_styling(latex_options = c("hold_position"),
                            font_size = 10)
```

```{r chap3-tab-gbd-long, echo = FALSE}
gbd_long %>% 
  knitr::kable(booktabs = TRUE,
               linesep = c(rep("", 3), "\\addlinespace"),
               align = c("l", "c", "c", "c", "c"),
               caption = "Global Burden of Disease data in analysis-friendly long format. This is tidy data.") %>% 
  kableExtra::kable_styling(latex_options = c("hold_position"),
                            font_size = 10)
```



```{r, echo = FALSE, fig.cap="Same data in the long ('tidy', necessary for efficient analysis) and wide (easier for human-readability/presentation/manual data entry) formats. TODO: replace with updated darta."}
knitr::include_graphics("images/wide_long.png")
```






