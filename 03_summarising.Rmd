---
output:
  pdf_document: default
  html_document: default
---

```{r, include = FALSE}
options(pillar.sigfig = 4)
```

# Summarising data

In this session we will get to know our three best friends for summarising data: `group_by()`, `summarise()`, and `mutate()`.

## Data: Global Burden of Disease (year, cause, sex, income, deaths)

```{r, include = FALSE}
source("healthyr_theme.R")
gbd_short = read_csv("data/global_burden_disease_SHORT.csv")
```


The Global Burden of Disease dataset used in this chapter is more detailed than the one we used previously. For each year, the total number of deaths from the three broad disease categories are also separated into sex and World Bank income categories. This means that we have 24 rows for each year, and that the total number of deaths per year is the sum of these 24 rows:


```{r, message=F}
library(tidyverse)
gbd_long  = read_csv("data/global_burden_disease_LONG.csv")

# Creating a single-year tibble for printing and simple examples:
gbd2017 = gbd_long %>% 
  filter(year == 2017)

```

```{r chap3-tab-gbd2017, echo = FALSE}
gbd2017 %>% 
  knitr::kable(booktabs = TRUE,
               linesep = c(rep("", 3), "\\addlinespace"),
               align = c("l", "c", "r", "l", "c", "r"),
               caption = "Deaths per year from three broad disease categories, sex, and World Bank county-level income groups.") %>% 
  kableExtra::kable_styling(latex_options = c("hold_position"),
                            font_size = 10)

```

\clearpage

The best way to investigate a dataset is of course to plot it. We have added a couple of notes as comments (the lines starting with a `#`) for those who can't wait to get to the next chapter where the code for plotting will be introduced and explained in detail. Overall, you shouldn't waste time trying to understand this code here but to look at the different groups within this new dataset.

```{r  chap03-fig-gbd, fig.height=3, fig.width=6, fig.cap="Global Burden of Disease data with subgroups: cause, sex, World Bank income group."}
gbd2017 %>% 
  # without the mutate(... = fct_relevel()) 
  # the panels get ordered alphabetically
  mutate(income = fct_relevel(income,
                              "Low",
                              "Lower-Middle",
                              "Upper-Middle",
                              "High")) %>% 
  # defining the variables using ggplot(aes(...)):
  ggplot(aes(x = sex, y = deaths_millions, fill = cause)) +
  # type of geom to be used: column (that's a type of barplot):
  geom_col(position = "dodge") +
  # facets for the income groups:
  facet_wrap(~income, ncol = 4) +
  # move the legend to the top of the plot (default is "right"):
  theme(legend.position = "top")
```

To quickly calculate the total number of deaths in 2017, we can select the column and send it into the `sum()` function:

```{r}
gbd2017$deaths_millions %>% sum()
```

But a much cleverer way of summarising data is using the `summarise()` function:

```{r}
gbd2017 %>% 
  summarise(sum(deaths_millions))
```

And this is indeed equal to the number of deaths per year we were looking at in the shorter version of this data (Deaths from the three causes were `r gbd_short %>%filter(year == 2017) %>% pull(deaths_millions)` which adds to `r gbd_short %>%filter(year == 2017) %>% pull(deaths_millions) %>% sum()`).

`sum()` is a function that adds numbers together, whereas `summarise()` is a clever and efficient way of creating summarised tibbles. The main strength of `sumarise()` is how it works together with the `group_by()` function. We use `group_by()` to tell `summarise()` which subgroups to apply the calculations on. In the above example, without `group_by()`, summarise just works on the whole dataset, yielding the same result as just sending a single column into the `sum()` function. But if we add `group_by()` like this, e.g., for the `cause` variable:

```{r}
gbd2017 %>% 
  group_by(cause) %>% 
  summarise(sum(deaths_millions))
```

Furthermore, `group_by()` is happy accept multiple grouping variables. So by just copying and editing the above code, we can quickly get summarised totals across mutliple grouping variables (by just adding `sex` inside the `group_by()` after `cause`):

```{r}
gbd2017 %>% 
  group_by(cause, sex) %>% 
  summarise(sum(deaths_millions))
```


Let's give the summarised column a better name, e.g. `deaths_pergroup`. And, if we use `ungroup()` we can use `mutate()` to add a total deaths column, and we can then use it to calculate a percentage:

```{r}
gbd2017 %>% 
  group_by(cause, sex) %>% 
  summarise(deaths_pergroup = sum(deaths_millions)) %>% 
  ungroup() %>% 
  mutate(deaths_total = sum(deaths_pergroup))
```

So `summarise()` condenses a tibble, whereas `mutate()` retains it's current size and adds columns. We can also further lines to `mutate()` to calculate the percentage of each group:

```{r, message = FALSE}
library(scales)
gbd2017 %>% 
  group_by(cause, sex) %>% 
  summarise(deaths_pergroup = sum(deaths_millions)) %>% 
  ungroup() %>% 
  mutate(deaths_total = sum(deaths_pergroup),
         deaths_relative = percent(deaths_pergroup/deaths_total))
```
