---
output:
  pdf_document: default
  html_document: default
  
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = FALSE)
```


## Sorting: `arrange()`

To reorder data ascendingly or descendingly, `use arrange()`:

```{r, results = 'hide'}
mydata %>% 
	group_by(year) %>% 
	summarise(total = sum(deaths_millions))  %>%
	arrange(-year) # reorder after summarise()
```


\newpage 

## Factor handling

We talked about the pros and cons of working with factors in Session 2. 
Overall, they are extremely useful for the type of analyses done in medical research. 

### Exercise
Explain how and why these two plots are different.

```{r, fig.width=5}

mydata %>%                                   
	ggplot(aes(x = year, y = deaths_millions, fill = cause))+  
	geom_col()

mydata %>% 
	ggplot(aes(x = factor(year), y = deaths_millions, fill = cause, colour = cause))+ 
	geom_col()
```

What about these?

```{r, fig.show = 'hold', fig.width=3.5, fig.height=3.5, echo=F}
ggplot <- function(...) ggplot2::ggplot(...)

mydata %>% 
	ggplot(aes(x = year, y = deaths_millions, fill = year, colour = year))+ 
	geom_col() +
	theme_bw()

mydata %>% 
	ggplot(aes(x = year, y = deaths_millions, fill = factor(year), colour = factor(year)))+ 
	geom_col()  +
	guides(fill = guide_legend(ncol=3)) +
	scale_fill_brewer(palette = "Dark2")+
	scale_colour_brewer(palette = "Dark2") +
	theme_bw() +
	theme(legend.position = "top")
```

These illustrate why it might sometimes be useful to use numbers as factors - on the second one we have used `fill = factor(year)` as the fill, so each year gets a distinct colour, rather than a gradual palette.

### `fct_collapse()` - grouping levels together


```{r}

mydata$cause  %>% 
	fct_collapse("Non-communicable and injuries" = c("Non-communicable diseases", "Injuries")) ->
	mydata$cause2

mydata$cause %>% levels()
mydata$cause2 %>% levels()
	
```

### `fct_relevel()` - change the order of levels

Another reason to sometimes make a numeric variable into a factor is that we can then reorder it for the plot:

```{r, fig.width=5}



mydata$year %>% 
  factor() %>% 
	fct_relevel("2013") -> #brings 2013 to the front
	mydata$year.factor

source("1_source_theme.R")

mydata %>% 
	ggplot(aes(x=year.factor, y=deaths_millions, fill=cause))+ 
	geom_col()

```

### `fct_recode()` - rename levels
```{r}
mydata$cause %>% 
	levels()  # levels() lists the factor levels of a column

mydata$cause %>% 
	fct_recode("Deaths from injury" = "Injuries") %>% 
	levels()
```

### Converting factors to numbers

MUST REMEMBER: factor needs to become `as.character()` before converting to numeric or date!
Factors are actually stored as labelled integers (so like number codes), only the function `as.character()` will turn a factor back into a collated format which can then be converted into a number or date.

### Exercise

Investigate the two examples converting the `year.factor` variable back to a number.

```{r}

mydata$year.factor

mydata$year.factor %>%
	as.numeric()

mydata$year.factor %>%
	as.character() %>% 
	as.numeric()


```

\newpage 
## Long Exercise

This exercise includes multiple steps, combining all of the above.

First, create a new script called "2_long_exercise.R". Then Restart your R session, add `library(tidyverse)` and load `"global_burden_disease_long.rda"`.

* Calculate the total number of deaths in Developed and Developing countries. Hint: use `group_by(location)` and `summarise(new-column-name = sum(variable-to-sum))`.
* Calculate the total number of deaths in Developed and Developing countries and for men and women. Hint: this is as easy as adding `, sex` to `group_by()`.
* Filter for 1990.
* `spread()` the `location` column.

```{r, echo = FALSE}

library(tidyverse)

load("global_burden_disease_long.rda")

mydata %>% 
  filter(year == 1990) %>% 
  group_by(location, sex) %>% 
  summarise(total_deaths = sum(deaths_millions)) %>% 
  spread(location, total_deaths)
  
```



## Extra: formatting a table for publication

Creating a publication table with both the total numbers and percentages (in brackets) + using `formatC()` to retain trailing zeros:

```{r}
# Let's use alldata from Exercise 5.2:

mydata %>% 
	group_by(year, cause) %>% 
	summarise(total_per_cause = sum(deaths_millions)) %>% 
	group_by(year) %>% 
	mutate(total_per_year = sum(total_per_cause)) %>% 
	mutate(percentage = 100*total_per_cause/total_per_year) -> alldata

alldata %>%
	mutate(total_percentage =	
				 	paste0(round(total_per_cause, 1)  %>% formatC(1, format = "f"),
				 	       " (", round(percentage, 1) %>% formatC(1, format = "f"),
				 	       "%)"
				 	       )
				 	) %>%
	select(year, cause, total_percentage) %>%
	spread(cause, total_percentage)
```


## Solution: Long Exercise

```{r, eval = FALSE}
mydata %>% 
  filter(year == 1990) %>% 
  group_by(location, sex) %>% 
  summarise(total_deaths = sum(deaths_millions)) %>% 
  spread(location, total_deaths)
  
```

