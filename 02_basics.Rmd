# R Basics

```{r, include = FALSE}
library(tidyverse)
```


The aim of this module is to familiarise you with how R works. 
We will read in data and start basic manipulations. 
We will be working with a shorter version of the Global Burden of Disease dataset that we met earlier. 


## Getting help

RStudio has a built in Help tab. 
To use the Help tab, click your cursor on something in your code (e.g. `read_csv()`) and press F1. This will show you the definition and some examples. 
However, the Help tab is only useful if you already know what you are looking for but can't remember exactly how it works. 
For finding help on things you have not used before, it is best to Google it. 
R has about 2 million users so someone somewhere has had the same question or problem.

\clearpage

## Objects and functions

The two fundamental concepts to understand about statistical programming are objects and functions. 
As usual, in this book, we prefer introducing new concepts using specific examples first.
And then define things in general terms after examples.

The most common data object you will be working with is a table - so something with rows and columns. 
It should be regular, e.g., the made-up example in Table \@ref(tab:chap2-examp1).

```{r chap2-examp1, echo = FALSE}

mydata = tibble(id   = 1:4,
       sex  = c("Male", "Female", "Female", "Male"),
       var1 = c(4, 1, 2, 3),
       var2 = c(NA, 4, 5, NA),
       var3 = c(2, 1, NA, NA))

mydata %>% 
  knitr::kable(booktabs = TRUE, caption = "Example of a table (=tibble once read into R), including missing values - denoted NA (Not applicable/Not available).")

```

Now, regular does not mean it can't have missing values.
Missing values are denoted `NA` that stands for either `Not available` or `Not applicable`. 
In same contexts, these things can have a different meaning, for example:

Since `var2` is `NA` for all Male subjects, it may mean "Not applicable", i.e. something that can only be measured in females.
Whereas in `var3`, `NA` is more likely to mean "Not available" so real missing data, e.g. lost to follow-up.
We will come back to handling missing values later, but let's return to introducing objects and functions.

A table can live anywhere: on paper, in a Spreadsheet, in an SQL database, or it can live in R session's Environment. 
And yes, R sessions are as fun as they sound, almost as fun as, e.g., music sessions. 
We usually initiate and interface R using RStudio, but everything we talk about here (objects, functions, sessions, enviroment) also work when RStudio is not available, but R is. 
This can be the case if you are working on a supercomputer that can only serve the R Console, and not an RStudio IDE (reminder from first chapter: Integrated Development Environment). 
So, regualarly shaped data in rows and columns is called table when it lives outside R. 
Once you read it into R (import it), we call it a tibble.
When you are in one of your very cool R sessions and read in a table, it goes into this session's Envionment. 
There used to be an older version of tables in R - they are called data frames. 
In most cases, `data frames` and `tibbles` work interchangeably (and both are R objects), but `tibbles` are newer and better. 
Another great alterntative to base R's `data frames` are `data tables`. 
In this book, and for most of our day-to-day work these days, we only use tibbles.

So, the tibble `mydata` example of an object that lives in the Environment of your R Session. 
A function that you may want to apply on numeric data is `mean()`. 
R functions always have brackets after their name. 
This is for two reasons. 
First, to easily differentiate them from objects - which don't have brackets after their name. 
Second, and more important, we can put arguments in these brackets. 
Arguments can also be thought of as input, and in data analysis, the most common input for a function is data: we need to give the R function `mean()` some data to average. 
It does not make sense (nor will it work) to feed it the whole tibble that has multiple columns, including patient IDs and a categorical variable (`sex`). 
To quickly extract a single column, we use the `$` symbol, like this:

```{r}
mydata$var1
```

You can ignore the `## [1]` at the beginning of the extracted values - this is something that becomes more useful when printing multiple lines of data, the number in the square brackets keeps count on how many values we are seeing.

We can then use `mydata$var1` as the first argument of `mean()` by putting it inside its brackets:

```{r}
mean(mydata$var1)
```

Which tells us that the mean of `var1` (`r mydata$var1`) is `r mean(mydata$var1)`.
In this example, `mydata$var1` is the first and only argument to `mean()`.
But what happens if we try to calculate the average value of `var2` (`r mydata$var2`)?

```{r}
mean(mydata$var2)
```

We get an `NA` ("Not applicable").
We would expect to see an `NA` if we tried to, for example, calculate the average of `sex`:

```{r, error=TRUE}
mean(mydata$sex)
```

In fact, R then gives as us a pretty clear Error (our first Error in this book!) saying it can't compute the mean of an argument that is not numeric or logical. 
The sentence actually reads pretty fun, as if R was saying it was not logical to calculate the mean of something that is not numeric. 
But what R is actually saying that it is happy to calculate the mean of two types of variables: numerics or logicals which is a data type with just two potential values TRUE/FALSE.
We will come back to data types shortly.

So `mean(mydata$var2)` does not return an Error, but it also doesn't return the mean of the numeric values included in this column. 
That is because the column includes missing values (`NAs`), and R does not want to average over NAs implicitly.
It is being cautious - what if you didn't know there were missing values for some patients?
If you wanted to compare the means of `var1` and `var2` without any further filtering, you would be comparing samples of different size. 
Which might be fine if the sample sizes are sufficiently representative and the values are missing at random. 
Therefore, if you decide to ignore the NAs and want to calculate the mean anyway, you can do so by adding another argument to `mean()`:

```{r}
mean(mydata$var2, na.rm = TRUE)
```

Adding `na.rm = TRUE` tells are that you are happy for it to calculate the mean of any existing values (but to remove - `na.rm` - the `NA` values).
This 'removal' only means excluded from the calculation, it does not affect the actual tibble (`mydata`) holding the columns and rows. 
R is case sensitive, so it has to be `na.rm`, not `NA.rm` etc. 
There is no need to try to memorise how the arguments of functions are exactly spelled - this is what the Help tab (press `F1` when the cursor is on the name of the function) can remind you of. 
Information about functions (Help) is built into R, so an internet connection is not required for this.

> Make sure to always separate arguments with commas, or R will give you an error of `Error: unexpected symbol`.

Finally, some functions do not need any arguments to work.
A good example is the `Sys.time()` which returns the current time and date. 
This is very useful when using R to generate and update reports automatically.
Including this on the output document means you as well as your colleagues can always be clear on when the results were last updated.

```{r}
Sys.time()
```

To summarise, objects and functions work hand in hand. 
Objects are both an input as well as the output of a function (what the function returns). 
The data values input into a function are usually its first argument, further arguments can be used to specify a functions behaviour. 
When we say "the function returns", we are referring to its output.
The returned object can be different to its input object.
In our `mean()` examples, the input object was a column (`mydata$var1`: `r mydata$var1`), whereas the output was a single value: `r mean(mydata$var1)`.



## Working with Objects


It's sometimes difficult to appreciate how coding works without trying it first.
These exercises will show you how R works.

We'll first create an object and call it `a`, we will give the object `a` a value of 1.
In R the equals `=` sign tells R to give the object on the left of the sign the value of whatever is on the right of the sign.

```{r, message=F}

a = 1

```

In your environment panel, you should see `a` appear under the `Values` section.

Now, lets create `b` and give it a value of 2.

```{r, message=F}

b = 2

```

Lets now add `a` and `b` together to create the object `c`

```{r, message=F}

c = a + b 

# Print the value of c to the Console

c # should return the number 3


```

All of R is just an extension of this: applying more complex functions (calculations) across more complex objects.

It's important to appreciate that objects can be more than just single numbers too. 
They can be entire spreadsheets, which in R are known as `tibbles` (or in base R: `data frames`).


Note that many people use `<-` instead of `=`. 
They mean the same thing in R. `=` and `<-` save what is on the right into the name on the left. 
There is also a left-to-right operator: `->`.

### Exercise

Create 3 new variables, `d`, `e`, `f` with values 6, 7, 8 using the different assignment operators.
```{r}
d  = 6
e <- 7
8 -> f
```


## Loading data

Before we load a new dataset, we should clear our experiments from the previous section. Restart R by pressing Ctrl+Shift+F10 or Select Section -> Restart R from the menu above.

Now the environment is clear, lets load in the data:

```{r, message=F}

library(tidyverse) # Tidyverse is the package which contains some of the code we want to use

mydata = read_csv("global_burden_disease_short.csv")

```

But how can we look at the data we just loaded? How do we know which variables it contains? 
Hint: the Environment tab.

### Exercise

Answer these question about your data:

1. At present, how many variables are there?

2. How many deaths were there from communicable diseases in 1990? Hint: clicking on columns when Viewing a tibble orders it.


### Other ways to investigate objects

In most cases, you can rely on the Environment tab to see how many variables you have. 
If, however, the dataset you are using is too big to easily navigate within, you might need to use `names(mydata)`, `head(mydata)`, or `str(mydata)`.

Furthermore, we can select a single column using the dollar sign: `$`.

So if we type:

```{r, message=F}

mydata$deaths

```

R will give us all the data for that variable.

### Exercise


![](images/magittr.png)

*Image source: https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html*

Re-write `names(mydata)` and `head(mydata)` using the pipe (`%>%`). Use the keyboard shortcut `Ctrl+Shift+M` to insert it.


### Exercise

How many unique values does the `cause` variable have? Hint: `mydata$cause` piped into `unique()` piped into `length()`.

## Operators

Operators are symbols in R Code that tell R how to handle different pieces of data or objects.

Here are the main operators:

`=, <-, ==, <, >, <=, >=`

Some of these perform a test on data. A good example of this is the '==' operator.

This tells R to compare two things and ask if they are equal. If they are equal R will return 'TRUE', if not R will return 'FALSE'.

On your R cheat sheet, you can see what the others do. Here is a reminder:

| Symbol  | What does  | Example  | Example result|
|-------- | ---------  | -------- |-------|
| `=` or `<-` |  assigns   |`x = 2`   | the value of x is now 2 |
| `==`      | Equal?     | `x == 2` | TRUE  |
| `!=`      | Not equal? | `x != 1` | TRUE |
| `<`       | Less than  | `x < 2`    | FALSE |
| `>`       | Greater than | `x > 1`   | TRUE |
| `<=`      | Less than or equal to | `x <= 2` | TRUE|
| `>=`      | Greater than or equal to | `x >= 1` | TRUE |
| `%>% `   | sends data into a function | `x %>% print()` | 2 |
| `::`     | indicates package | `dplyr::count()` | `count()` fn. from the `dplyr` package|
| `->`            | assigns | `2 -> x` | the value of x is now 2 |
| `&`             | AND | `x > 1 & x < 3` | TRUE |
| `|`             | OR | `x > 3 | x == 3` | TRUE |
| `%in%`          | is value in list | `x %in% c(1,2,3)` | TRUE |
| `$`             | select a column | `mydata$year` | 1990,1996,...|
| `c()`           | combines values | `c(1, 2)`     | 1, 2 |
| `#`               | comment| `#Riinu changed this` | ignored by R   |


For example, if we wanted to select the years in the Global Burden of disease study after 2000 (and including 2000) we could type the following:

```{r, results='hide'}

mydata %>% 
  filter(year >= 2000)

```


To save this as a new object we would then write:


```{r, results='hide'}

mydata_out = mydata %>% 
  filter(year >= 2000)

# Or we could write

mydata %>% 
  filter(year >= 2000) -> mydata_out

```

How would you change the above code to only include years greater than 2000 (so not including 2000 itself too)? Hint: look at the table of operators above (also in your HealthyR QuickStart Sheet).

### Exercise

Modify the above example to filter for only year 2000, not all years greater than 2000. Save it into a variable called `mydata_year2000`.

```{r, echo = FALSE}

mydata_year2000 = mydata %>% 
  filter(year == 2000)

```


### Exercise

Let's practice this and combine multiple selections together.

This '|' means OR and '&' means AND.

From `mydata`, select the lines where year is either 1990 or 2013 and cause is "Communicable diseases":

```{r}

new_data_selection = mydata %>% 
  filter( (year == 1990 | year == 2013) & cause == "Communicable diseases")

# Or we can get rid of the extra brackets around the years
# by moving cause into a new filter on a new line:

new_data_selection = mydata %>% 
  filter(year == 1990 | year == 2013) %>% 
  filter(cause == "Communicable diseases")


```



## Types of variables

**consider structuring as per here: https://finalfit.org/articles/data_prep.html**

Like many other types of statistical software, R needs to know the variable type of each column. The main types are:

### Characters

**Characters** (sometimes referred to as *strings* or *character strings*) in R are letters, words, or even whole sentences (an example of this may be free text comments). 
We can specify these using the `as.character()` function. Characters are displayed in-between `""` (or `''`).

### Factors

**Factors** are fussy characters. 
Factors are fussy because they have something called levels. 
Levels are all the unique values this variable could take - e.g. like when we looked at `mydata$cause %>% unique()`.
Using factors rather than just characters can be useful because:


* The values factor levels can take is fixed. 
For example, if the levels of your column called `sex` are "Male" and "Female" and you try to add a new patient where sex is called just "F" you will get a warning from R. 
If `sex` was a character column rather than a factor R would have no problem with this and you would end up with "Male", "Female", and "F" in your column.
* Levels have an order. 
When we plotted the different causes of death in the last session, R ordered them alphabetically (because `cause` was a character rather than a factor). 
But if you want to use a non-alphabetical order, e.g. "Communicable diseases"-"Non-communicable diseases"-"Injuries", we need make `cause` into a factor. 
Making a character column into a factor enables us to define and change the order of the levels. 
Furthermore, there are useful tools such as `fct_inorder` or `fct_infreq` that can order factor levels for us.


These can be huge benefits, especially as a lot of medical data analyses include comparing different risks to a reference level. 
Nevertheless, the fussiness of factors can sometimes be unhelpful or even frustrating. 
For example, if you really did want to add a new level to your `gender` column (e.g., "Prefer not to say") you will either have to convert the column to a character, add it, and convert it back to a factor, or use `fct_expand` to add the level and then add your new line.

#### Exercise

Temporarily type `fct_inorder` anywhere in your script, then press F1. 
Read the **Description** in the Help tab and discuss with your neighbour how `fct_inorder` and `fct_infreq` would order your factor levels.


### Numbers

Self-explanatory! 
These are numbers. 
In R, we specify these using the `as.numeric()` function. 
Numbers without decimal places are sometimes called integers. 
Click on the blue arrow in front of `mydata` in the Environment tab and see that `year` is an `int` (integer) whereas `deaths` is a `num` (numeric).




### Specifying variable types

```{r, eval = FALSE}

as.character(mydata$cause)

as.numeric(mydata$year)

factor(mydata$year)

#Lets save the cause as a factor

mydata$cause = factor(mydata$cause)

#Now lets print it out

mydata$cause

```

### Exercise

Change the order of the levels in `mydata$cause` so that "Non-communicable diseases" come before "Injuries". 
Hint: use F1 to investigate examples of how `fct_relevel()` works.

## Importing data

For historical reasons, R's default functions (e.g. `read.csv()` or `data.frame()`) convert all characters to factors automatically (for more on this see [forcats.tidyverse.org](http://forcats.tidyverse.org). 
But it is usually more convenient to deal with characters and convert some of the columns to factors when necessary.

Base R:

```{r}

mydata = read.csv("global_burden_disease_short.csv", stringsAsFactors = FALSE)

```

The tidyverse version, `read_csv()`, has `stringsAsFactors` set to FALSE by default (and it is a lot faster than `read.csv()` when reading in large datasets).

Tidyverse:

```{r}

mydata = read_csv("global_burden_disease_short.csv")

```

You can use the "Import Dataset" button in the Environment tab to get the code for importing data from Excel, SPSS, SAS, or Stata.

## Adding columns to dataframes

If we wanted to add in a new column or variable to our data, we can simply use the dollar sign '$' to create a new variable inside a pre-existing piece of data:

```{r}

mydata$new = 1

mydata$new2 = 1:18

```

Run these lines and click on `mydata` in the Environment tab to check this worked as expected.

Conversely, if we want to delete a specific variable or column we can use the 'NULL' function, or alternatively ask R to `select()` the data without the new variable included.

```{r}

mydata$new = NULL

mydata = mydata %>% 
  select(-new2)

```

We can make new variables using calculations based on variables in the data too.

The mutate function is useful here. 
All you have to specify within the mutate function is the name of the variable (this can be new or pre-existing) and where the new data should come from.

There are two equivalent ways of defining new columns based on a calculation with a previous column:

**mutate formally introduced in later chapter. Need to think how best to present this in book.**

```{r}

# First option

mydata$years_from_1990 = mydata$year - 1990 
mydata$deaths_millions = mydata$deaths/1000000

# Second option (mutate() function)

mydata = mydata %>% 
  mutate(years_from_1990 = year-1990,
         deaths_millions = deaths/1000000) 

```

Throughout this course we will be using both of these ways to create or modify columns. 
The first option (using the `$`) can look neater when changing a single variable, but when combining multiple ones you will end up repeating `mydata$`. 
`mutate()` removes the duplication, but it does add a new line and brackets. 


## Rounding numbers

We can use `round()` to round the new variables to create integers.

### Exercise

Round the new column `deaths_millions` to no decimals:

```{r, echo = FALSE}

mydata$deaths_millions = round(mydata$deaths_millions)

mydata$deaths_millions

```

* How would you round it to 2 decimals? Hint: use F1 to investigate `round()`. 

* What do `ceiling()` and `floor()` do? Hint: sometimes you want to round a number up or down.

## The combine function: c()

The combine function combines several values: `c()`

The combine function can be used with numbers or characters (like words or letters):

```{r}

examplelist = c("Red", "Yellow", "Green", "Blue")

# Ask R to print it by executing it on its own line

examplelist

```

### Exercise

There are 18 lines (observations) in mydata. 
Create a new variable using `c()` with 18 values (numbers, words, whichever you like, e.g. like we created `examplelist`). 
Then add it as new column to `mydata$newlist`. 
Advanced version: do this using a combination of `rep()` and `c()`.

\newpage
## The `paste()` function

The `paste()` function is used to paste several words or numbers into one character variable/sentence.

In the paste function we need to specify what we would like to combine, and what should separate the components. 
By default, the separation is a space, but we can change this using the `sep =` option within the paste function.

So, for example if we wanted to make a sentence:

```{r pasteexample1}

# 
#paste("Edinburgh", "is", "Great")

# Lets add in full stops


paste("Edinburgh", "is", "Great", sep = ".")
# separator needs to go in "" as it is a character


# If we really like Edinburgh

#paste("Edinburgh", "is", "Great", sep = "!")

# If we want to make it one word

#paste("Edinburgh", "is", "Great", sep = "") # no separator (still need the brackets)

```

We can also join two different variables together using `paste()`: 


```{r pasteexample2}

paste("Year is", mydata$year)

```


### Exercise

Fix this code:

Hint: Think about characters and quotes!

```{r, eval=F}

paste(Today is, Sys.Date() )

```


## Combining two dataframes

For combining dataframes based on shared variables we use the joins: `left_join()`, `right_join()`, `inner_join()`, or `full_join()`. 
Let's split some of the variables in `mydata` between two new dataframes: `first_data` and `second_data`. 
For demonstrating the difference between the different joins, we will only include a subset (first 6 rows) of the dataset in `second_data`:

```{r, message = FALSE}

first_data  = select(mydata, year, cause, deaths_millions)
second_data = select(mydata, year, cause, deaths_millions) %>% slice(1:6)

# change the order of rows in first_data to demosntrate the join does not rely on the ordering of rows:
first_data = arrange(first_data, deaths_millions)

combined_left  =  left_join(first_data, second_data)
combined_right = right_join(first_data, second_data)
combined_inner = inner_join(first_data, second_data)
combined_full  =  full_join(first_data, second_data)


```

Those who have used R before, or those who come across older scripts will have seen `merge()` instead of the joins. 
`merge()` works similarly to joins, but instead of having the four options defined clearly at the front, you would have had to use the `all = FALSE, all.x = all, all.y = all` arguments.

![](images/databasejoke.jpg)

### Exercise

Investigate the four new dataframes called `combined_` using the Environment tab and discuss how the different joins (left, right, inner, full) work.


## The `summary()` function

In R, the `summary()` function provides a quick way of summarising both data or the results of statistical tests.

Lets get a quick summary of all the variables inside the Global Burden of Disease dataset. 
It will work for whole datasets and single variables too.

```{r}

mydata %>% summary()

```

This even works on statistical tests (we will learn more about these later):

```{r}

# lm stands for linear model
lm(deaths ~ year, data = mydata) %>% summary()

```

### When pipe sends data to the wrong place

Note that our usual way of doing things with the pipe would not work here:


```{r, eval = FALSE}

mydata %>% 
  lm(deaths ~ year) %>%
  summary()

```

This is because the pipe tries to send data into the first place of the function (first argument), but `lm()` wants the formula (`deaths ~ year`) first, then the dataframe. 
We can bypass this using `data = .` to tell the pipe where to put mydata:

```{r, eval = FALSE}

mydata %>% 
  lm(deaths ~ year, data = .) %>%
  summary()

```


### Exercise

Try adding a new variable called `death_over_10m` which indicates whether there were more than 10 million deaths for a cause. 
The new variable should take the form 'Yes' or 'No'. 

Then make it into a factor.

Then use `summary()` to find out about it!
```{r}

mydata = mydata %>% 
  mutate(death_over_10m = ifelse(deaths >= 10000000, "Yes", "No")) # Using ifelse

mydata$death_over_10m = as.factor(mydata$death_over_10m)

mydata$death_over_10m %>% summary()

```

## Extra: Creating a dataframe from scratch

It is rare that you will need to create a data frame by hand as most of the time you will be reading in a data from a .csv or similar. 
But in some cases (e.g. when creating special labels for a plot) it might be useful, so this is how to create one:


```{r}

patient_id = paste0("ID", 1:10)
sex        = rep(c("Female", "Male"), 5)
age        = 18:27

newdata = data_frame(patient_id, sex, age)

# same as

newdata      = data_frame(
  patient_id = paste0("ID", 1:10), #note the commas
  sex        = rep(c("Female", "Male"), 5),
  age        = 18:27
)


```


If we used `data.frame()` instead of `data_frame()`, all our character variables (`patient_id`, `sex`) would become factors automatically. 
This might make sense for `sex`, but it doesn't for `patient_id`.

### Exercise

Create a new dataframe called `my_dataframe` that looks like this:

Hint: Use the functions `paste0()`, `seq()` and `rep()`


```{r, echo=F}

my_dataframe = data_frame(
  patient_id = paste0("ID", 11:20),
  age        = seq(15, 60, 5),
  sex        = c( rep("Male", 5), rep("Female", 5))
)

my_dataframe

```


## Solutions

**2.5.3**

```{r, eval = FALSE}

mydata %>% names()
mydata %>% head()
mydata %>% str()

```

**2.5.4**

```{r}

mydata$cause %>% unique() %>% length()

```

**2.6.2**

```{r}

mydata_year2000 = mydata %>% 
  filter(year == 2000)

```

**2.7.5** 

```{r, eval = FALSE}
mydata$cause %>% fct_relevel("Injuries", after = 1)
```

**2.10.1**

```{r, message = FALSE}
mydata$deaths_millions = round(mydata$deaths_millions)

# or
mydata$deaths_millions = mydata$deaths_millions %>% round()


```

**2.11.1**

```{r}

examplelist = c("Red", "Yellow", "Green", "Blue",
                "Red", "Yellow", "Green", "Blue",
                "Red", "Yellow", "Green", "Blue",
                "Red", "Yellow", "Green", "Blue",
                "Green", "Blue")

#Let's see what we've made by using print

mydata$newlist = examplelist


# using rep()

examplelist2 = rep(c("Green", "Red"), 9)

```


**2.12.1**

```{r, eval = FALSE}
paste("Today is", Sys.Date())
```

**2.15.1**

```{r}

my_dataframe = data_frame(
  patient_id = paste0("ID", 11:20),
  age        = seq(15, 60, 5),
  sex        = c( rep("Male", 5), rep("Female", 5))
)

```
